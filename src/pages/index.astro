---
import Layout from '../layouts/Layout.astro';
import NewConnectionForm from '../components/NewConnectionForm.astro';
import ThemeToggle from '../components/ThemeToggle.astro';
---

<Layout>
	<div class="min-h-screen bg-background text-foreground p-4">
		<div class="max-w-7xl mx-auto">
			<div class="flex items-center justify-between mb-6">
				<h1 class="text-3xl font-bold">Socket.IO Client Tester</h1>
				<ThemeToggle />
			</div>

			<div class="mb-6">
				<NewConnectionForm />
			</div>

			<!-- Connections Container -->
			<div id="connectionsContainer" class="space-y-4">
				<!-- Connections will be added here dynamically -->
			</div>
		</div>
	</div>
</Layout>

<script>
	import { io } from 'socket.io-client';
	import { EditorView, ViewUpdate } from '@codemirror/view';
	import { EditorState } from '@codemirror/state';
	import { json } from '@codemirror/lang-json';

	interface ConnectionState {
		id: string;
		socket: ReturnType<typeof io> | null;
		url: string;
		namespace: string;
		connected: boolean;
		rooms: string[];
		eventListeners: Set<string>;
		eventLog: Array<{ timestamp: string; type: 'sent' | 'received' | 'system'; event: string; data: unknown }>;
		editor: EditorView | null;
	}

	class SocketManager {
		private connections: Map<string, ConnectionState> = new Map();
		private connectionCounter = 0;

		createConnection(url: string, namespace: string): string {
			const id = `conn-${++this.connectionCounter}`;
			const namespacePath = namespace.trim() || '/';
			const fullUrl = `${url}${namespacePath}`;

			const state: ConnectionState = {
				id,
				socket: null,
				url,
				namespace: namespacePath,
				connected: false,
				rooms: [],
				eventListeners: new Set(),
				eventLog: [],
				editor: null,
			};

			this.connections.set(id, state);
			this.renderConnection(state);
			return id;
		}

		connect(id: string): void {
			const state = this.connections.get(id);
			if (!state || state.connected) return;

			try {
				const socket = io(state.url + state.namespace, {
					transports: ['websocket', 'polling'],
				});

				socket.on('connect', () => {
					state.connected = true;
					state.socket = socket;
					this.addLog(id, 'system', 'connected', {});
					this.updateConnectionUI(state);
				});

				socket.on('disconnect', () => {
					state.connected = false;
					this.addLog(id, 'system', 'disconnected', {});
					this.updateConnectionUI(state);
				});

				socket.on('connect_error', (error: Error) => {
					this.addLog(id, 'system', 'connect_error', { error: error.message });
					this.updateConnectionUI(state);
				});

				// Listen for all registered events
				state.eventListeners.forEach((eventName) => {
					socket.on(eventName, (data: unknown) => {
						this.addLog(id, 'received', eventName, data);
					});
				});

				state.socket = socket;
			} catch (error) {
				this.addLog(id, 'system', 'error', { error: (error as Error).message });
			}
		}

		disconnect(id: string): void {
			const state = this.connections.get(id);
			if (!state || !state.socket) return;

			state.socket.disconnect();
			state.socket = null;
			state.connected = false;
			state.rooms = [];
			this.updateConnectionUI(state);
		}

		removeConnection(id: string): void {
			const state = this.connections.get(id);
			if (state) {
				this.destroyEditor(state);
			}
			this.disconnect(id);
			this.connections.delete(id);
			const element = document.getElementById(`connection-${id}`);
			if (element) element.remove();
		}

		joinRoom(id: string, room: string): void {
			const state = this.connections.get(id);
			if (!state || !state.socket || !state.connected) return;

			if (state.rooms.includes(room)) return;

			state.socket.emit('join', room);
			state.rooms.push(room);
			this.addLog(id, 'sent', 'join', { room });
			this.updateConnectionUI(state);
		}

		leaveRoom(id: string, room: string): void {
			const state = this.connections.get(id);
			if (!state || !state.socket || !state.connected) return;

			state.socket.emit('leave', room);
			state.rooms = state.rooms.filter((r) => r !== room);
			this.addLog(id, 'sent', 'leave', { room });
			this.updateConnectionUI(state);
		}

		addEventListener(id: string, eventName: string): void {
			const state = this.connections.get(id);
			if (!state) return;

			if (state.eventListeners.has(eventName)) return;

			state.eventListeners.add(eventName);
			if (state.socket && state.connected) {
				state.socket.on(eventName, (data: unknown) => {
					this.addLog(id, 'received', eventName, data);
				});
			}
			this.updateConnectionUI(state);
		}

		removeEventListener(id: string, eventName: string): void {
			const state = this.connections.get(id);
			if (!state) return;

			state.eventListeners.delete(eventName);
			if (state.socket && state.connected) {
				state.socket.off(eventName);
			}
			this.updateConnectionUI(state);
		}

		sendEvent(id: string, eventName: string, data: unknown): void {
			const state = this.connections.get(id);
			if (!state || !state.socket || !state.connected) return;

			state.socket.emit(eventName, data);
			this.addLog(id, 'sent', eventName, data);
		}

		private addLog(id: string, type: 'sent' | 'received' | 'system', event: string, data: unknown): void {
			const state = this.connections.get(id);
			if (!state) return;

			const timestamp = new Date().toLocaleTimeString();
			state.eventLog.push({ timestamp, type, event, data });

			// Keep only last 100 logs
			if (state.eventLog.length > 100) {
				state.eventLog.shift();
			}

			this.updateLogUI(state);
		}

		private initializeEditor(state: ConnectionState): void {
			const editorContainer = document.querySelector(`.event-data-editor[data-id="${state.id}"]`) as HTMLElement;
			if (!editorContainer || state.editor) return;

			const isDark = document.documentElement.classList.contains('dark');
			const darkTheme = EditorView.theme({
				'&': {
					backgroundColor: isDark ? 'hsl(217.2, 32.6%, 17.5%)' : '#ffffff',
					color: isDark ? 'hsl(210, 40%, 98%)' : '#222222',
					height: '100%',
					borderRadius: '0.375rem',
				},
				'.cm-content': {
					padding: '12px',
					minHeight: '100px',
					fontSize: '14px',
					fontFamily: 'ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace',
					caretColor: isDark ? 'hsl(217.2, 91%, 60%)' : 'hsl(217.2, 91%, 60%)',
				},
				'.cm-focused': {
					outline: 'none',
				},
				'.cm-gutters': {
					backgroundColor: isDark ? 'hsl(217.2, 32.6%, 20%)' : '#f8f9fa',
					border: 'none',
				},
				'.cm-lineNumbers .cm-gutterElement': {
					color: isDark ? 'hsl(215, 20.2%, 65.1%)' : '#6b7280',
					padding: '0 8px',
				},
				'.cm-cursor': {
					borderLeftColor: isDark ? 'hsl(217.2, 91%, 60%)' : 'hsl(217.2, 91%, 60%)',
				},
				'.cm-selectionBackground': {
					backgroundColor: isDark ? 'hsl(217.2, 32.6%, 25.5%)' : '#e5e7eb',
				},
			});

			const startState = EditorState.create({
				doc: '',
				extensions: [
					json(),
					darkTheme,
					EditorView.lineWrapping,
					EditorState.tabSize.of(2),
					EditorView.updateListener.of((update: ViewUpdate) => {
						if (update.docChanged) {
							// Auto-format on blur could be added here if needed
						}
					}),
				],
			});

			const editor = new EditorView({
				state: startState,
				parent: editorContainer,
			});

			state.editor = editor;
		}

		private destroyEditor(state: ConnectionState): void {
			if (state.editor) {
				state.editor.destroy();
				state.editor = null;
			}
		}

		updateEditorTheme(state: ConnectionState): void {
			if (!state.editor) return;
			
			const isDark = document.documentElement.classList.contains('dark');
			const newTheme = EditorView.theme({
				'&': {
					backgroundColor: isDark ? 'hsl(217.2, 32.6%, 17.5%)' : '#ffffff',
					color: isDark ? 'hsl(210, 40%, 98%)' : '#222222',
				},
				'.cm-content': {
					caretColor: 'hsl(217.2, 91%, 60%)',
				},
				'.cm-gutters': {
					backgroundColor: isDark ? 'hsl(217.2, 32.6%, 20%)' : '#f8f9fa',
				},
				'.cm-lineNumbers .cm-gutterElement': {
					color: isDark ? 'hsl(215, 20.2%, 65.1%)' : '#6b7280',
				},
				'.cm-cursor': {
					borderLeftColor: 'hsl(217.2, 91%, 60%)',
				},
				'.cm-selectionBackground': {
					backgroundColor: isDark ? 'hsl(217.2, 32.6%, 25.5%)' : '#e5e7eb',
				},
			});
			
			// Update theme by recreating the editor state
			const currentDoc = state.editor.state.doc.toString();
			const newState = EditorState.create({
				doc: currentDoc,
				extensions: [
					json(),
					newTheme,
					EditorView.lineWrapping,
					EditorState.tabSize.of(2),
					EditorView.updateListener.of((update: ViewUpdate) => {
						if (update.docChanged) {
							// Auto-format on blur could be added here if needed
						}
					}),
				],
			});
			
			state.editor.setState(newState);
		}

		private renderConnection(state: ConnectionState): void {
			const container = document.getElementById('connectionsContainer');
			if (!container) return;

			const connectionDiv = document.createElement('div');
			connectionDiv.id = `connection-${state.id}`;
			connectionDiv.innerHTML = this.getConnectionHTML(state);
			container.appendChild(connectionDiv);

			this.attachEventListeners(state);
		}

		private getConnectionHTML(state: ConnectionState): string {
			const statusBadge = state.connected 
				? '<span class="inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors bg-green-500/20 text-green-400 border-green-500/50">Conectado</span>'
				: '<span class="inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors bg-red-500/20 text-red-400 border-red-500/50">Desconectado</span>';

			return `
				<div class="rounded-lg border bg-card text-card-foreground shadow-sm p-6 mb-4">
					<div class="flex items-center justify-between mb-4">
						<div class="flex items-center gap-3">
							<div class="w-3 h-3 rounded-full ${state.connected ? 'bg-green-500' : 'bg-red-500'}"></div>
							<h3 class="text-xl font-semibold">${state.url}${state.namespace}</h3>
							${statusBadge}
						</div>
						<div class="flex gap-2">
							${state.connected ? `
								<button class="disconnect-btn inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-destructive text-destructive-foreground hover:bg-destructive/90 h-9 px-3 rounded-md" data-id="${state.id}">
									Disconnect
								</button>
							` : `
								<button class="connect-btn inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-primary text-primary-foreground hover:bg-primary/90 h-9 px-3 rounded-md" data-id="${state.id}">
									Connect
								</button>
							`}
							<button class="remove-btn inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-9 px-3 rounded-md" data-id="${state.id}">
								Remove
							</button>
						</div>
					</div>

					<div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
						<!-- Left Column: Rooms & Event Listeners -->
						<div class="space-y-4">
							<!-- Rooms Section -->
							<div class="rounded-lg border bg-card text-card-foreground shadow-sm p-6">
								<h4 class="text-lg font-semibold mb-4">Rooms</h4>
								<div class="flex gap-2 mb-2">
									<input
										type="text"
										class="room-input flex-1 flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
										placeholder="Room name"
										data-id="${state.id}"
									/>
									<button class="join-room-btn inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-primary text-primary-foreground hover:bg-primary/90 h-9 rounded-md px-3" data-id="${state.id}">
										Join
									</button>
								</div>
								<div class="rooms-list space-y-2" data-id="${state.id}">
									${state.rooms.length === 0 ? '<p class="text-sm text-muted-foreground">No rooms joined</p>' : ''}
									${state.rooms.map((room) => `
										<div class="flex items-center justify-between bg-muted rounded-md p-2">
											<span class="text-sm font-medium">${room}</span>
											<button class="leave-room-btn inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-destructive text-destructive-foreground hover:bg-destructive/90 h-8 rounded-md px-2 text-xs" data-id="${state.id}" data-room="${room}">
												Leave
											</button>
										</div>
									`).join('')}
								</div>
							</div>

							<!-- Event Listeners Section -->
							<div class="rounded-lg border bg-card text-card-foreground shadow-sm p-6">
								<h4 class="text-lg font-semibold mb-4">Listen to Events</h4>
								<div class="flex gap-2 mb-2">
									<input
										type="text"
										class="listener-input flex-1 flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
										placeholder="Event name"
										data-id="${state.id}"
									/>
									<button class="add-listener-btn inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-primary text-primary-foreground hover:bg-primary/90 h-9 rounded-md px-3" data-id="${state.id}">
										Add
									</button>
								</div>
								<div class="listeners-list space-y-2" data-id="${state.id}">
									${state.eventListeners.size === 0 ? '<p class="text-sm text-muted-foreground">No active listeners</p>' : ''}
									${Array.from(state.eventListeners).map((eventName) => `
										<div class="flex items-center justify-between bg-muted rounded-md p-2">
											<code class="text-sm font-mono">${eventName}</code>
											<button class="remove-listener-btn inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-destructive text-destructive-foreground hover:bg-destructive/90 h-8 rounded-md px-2 text-xs" data-id="${state.id}" data-event="${eventName}">
												Remove
											</button>
										</div>
									`).join('')}
								</div>
							</div>

							<!-- Send Event Section -->
							<div class="rounded-lg border bg-card text-card-foreground shadow-sm p-6">
								<h4 class="text-lg font-semibold mb-4">Send Event</h4>
								<input
									type="text"
									class="event-name-input w-full mb-2 flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50"
									placeholder="Event name"
									data-id="${state.id}"
								/>
								<div
									class="event-data-editor w-full border rounded-md mb-2 overflow-hidden bg-background"
									data-id="${state.id}"
									style="min-height: 100px;"
								></div>
								<button class="send-event-btn w-full inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 bg-primary text-primary-foreground hover:bg-primary/90 h-10 px-4 py-2" data-id="${state.id}">
									Send
								</button>
							</div>
						</div>

						<!-- Right Column: Event Log -->
						<div class="rounded-lg border bg-card text-card-foreground shadow-sm p-6">
							<div class="flex items-center justify-between mb-4">
								<h4 class="text-lg font-semibold">Event Log</h4>
								<button class="clear-log-btn inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 border border-input bg-background hover:bg-accent hover:text-accent-foreground h-9 rounded-md px-2 text-xs" data-id="${state.id}">
									Clear
								</button>
							</div>
							<div class="relative overflow-hidden rounded-md border bg-background h-96">
								<div class="h-full w-full rounded-[inherit] overflow-y-scroll p-4">
									<div class="event-log space-y-2" data-id="${state.id}">
										${state.eventLog.length === 0 ? '<p class="text-sm text-muted-foreground">No events yet</p>' : ''}
										${state.eventLog.map((log) => {
											const typeColor = log.type === 'sent' ? 'text-blue-400 border-blue-500' : log.type === 'received' ? 'text-green-400 border-green-500' : 'text-yellow-400 border-yellow-500';
											return `
												<div class="border-l-2 pl-2 ${typeColor}">
													<div class="flex items-center gap-2 mb-1">
														<span class="text-xs text-muted-foreground">${log.timestamp}</span>
														<span class="text-xs font-semibold uppercase">${log.type}</span>
														<span class="text-sm font-medium">${log.event}</span>
													</div>
													<pre class="text-xs whitespace-pre-wrap break-words text-muted-foreground">${JSON.stringify(log.data, null, 2)}</pre>
												</div>
											`;
										}).join('')}
									</div>
								</div>
							</div>
						</div>
					</div>
				</div>
			`;
		}

		private updateConnectionUI(state: ConnectionState): void {
			const element = document.getElementById(`connection-${state.id}`);
			if (!element) return;

			this.destroyEditor(state);
			element.innerHTML = this.getConnectionHTML(state);
			this.attachEventListeners(state);
		}

		private updateLogUI(state: ConnectionState): void {
			const logElement = document.querySelector(`.event-log[data-id="${state.id}"]`);
			if (!logElement) return;

			const lastLog = state.eventLog[state.eventLog.length - 1];
			if (!lastLog) return;

			const typeColor = lastLog.type === 'sent' ? 'text-blue-400 border-blue-500' : lastLog.type === 'received' ? 'text-green-400 border-green-500' : 'text-yellow-400 border-yellow-500';

			const logEntry = document.createElement('div');
			logEntry.className = `border-l-2 pl-2 ${typeColor}`;
			logEntry.innerHTML = `
				<div class="flex items-center gap-2 mb-1">
					<span class="text-xs text-muted-foreground">${lastLog.timestamp}</span>
					<span class="text-xs font-semibold uppercase">${lastLog.type}</span>
					<span class="text-sm font-medium">${lastLog.event}</span>
				</div>
				<pre class="text-xs whitespace-pre-wrap break-words text-muted-foreground">${JSON.stringify(lastLog.data, null, 2)}</pre>
			`;

			logElement.appendChild(logEntry);

			// Auto-scroll to bottom
			logElement.scrollTop = logElement.scrollHeight;

			// Keep only last 100 visible
			const children = logElement.children;
			if (children.length > 100) {
				logElement.removeChild(children[0]);
			}
		}

		private attachEventListeners(state: ConnectionState): void {
			const id = state.id;

			// Connect/Disconnect
			document.querySelector(`.connect-btn[data-id="${id}"]`)?.addEventListener('click', () => {
				this.connect(id);
			});
			document.querySelector(`.disconnect-btn[data-id="${id}"]`)?.addEventListener('click', () => {
				this.disconnect(id);
			});

			// Remove connection
			document.querySelector(`.remove-btn[data-id="${id}"]`)?.addEventListener('click', () => {
				this.removeConnection(id);
			});

			// Join room
			const joinRoomBtn = document.querySelector(`.join-room-btn[data-id="${id}"]`);
			const roomInput = document.querySelector(`.room-input[data-id="${id}"]`) as HTMLInputElement;
			joinRoomBtn?.addEventListener('click', () => {
				const room = roomInput?.value.trim();
				if (room) {
					this.joinRoom(id, room);
					if (roomInput) roomInput.value = '';
				}
			});
			roomInput?.addEventListener('keypress', (e) => {
				if (e.key === 'Enter') {
					const room = roomInput.value.trim();
					if (room) {
						this.joinRoom(id, room);
						roomInput.value = '';
					}
				}
			});

			// Leave room
			document.querySelectorAll(`.leave-room-btn[data-id="${id}"]`).forEach((btn) => {
				btn.addEventListener('click', (e) => {
					const room = (e.target as HTMLElement).getAttribute('data-room');
					if (room) this.leaveRoom(id, room);
				});
			});

			// Add event listener
			const addListenerBtn = document.querySelector(`.add-listener-btn[data-id="${id}"]`);
			const listenerInput = document.querySelector(`.listener-input[data-id="${id}"]`) as HTMLInputElement;
			addListenerBtn?.addEventListener('click', () => {
				const eventName = listenerInput?.value.trim();
				if (eventName) {
					this.addEventListener(id, eventName);
					if (listenerInput) listenerInput.value = '';
				}
			});
			listenerInput?.addEventListener('keypress', (e) => {
				if (e.key === 'Enter') {
					const eventName = listenerInput.value.trim();
					if (eventName) {
						this.addEventListener(id, eventName);
						listenerInput.value = '';
					}
				}
			});

			// Remove event listener
			document.querySelectorAll(`.remove-listener-btn[data-id="${id}"]`).forEach((btn) => {
				btn.addEventListener('click', (e) => {
					const eventName = (e.target as HTMLElement).getAttribute('data-event');
					if (eventName) this.removeEventListener(id, eventName);
				});
			});

			// Initialize editor
			this.initializeEditor(state);

			// Send event
			const sendEventBtn = document.querySelector(`.send-event-btn[data-id="${id}"]`);
			const eventNameInput = document.querySelector(`.event-name-input[data-id="${id}"]`) as HTMLInputElement;
			sendEventBtn?.addEventListener('click', () => {
				const eventName = eventNameInput?.value.trim();
				if (!eventName) return;

				let data: unknown = {};
				const editorContent = state.editor?.state.doc.toString().trim();
				if (editorContent) {
					try {
						data = JSON.parse(editorContent);
					} catch (error) {
						alert('Error: Invalid JSON');
						return;
					}
				}

				this.sendEvent(id, eventName, data);
				if (eventNameInput) eventNameInput.value = '';
				if (state.editor) {
					const transaction = state.editor.state.update({
						changes: { from: 0, to: state.editor.state.doc.length, insert: '' },
					});
					state.editor.dispatch(transaction);
				}
			});

			// Clear log
			document.querySelector(`.clear-log-btn[data-id="${id}"]`)?.addEventListener('click', () => {
				state.eventLog = [];
				const logElement = document.querySelector(`.event-log[data-id="${id}"]`);
				if (logElement) logElement.innerHTML = '<p class="text-gray-500">No events yet</p>';
			});
		}
	}

	// Initialize manager
	const manager = new SocketManager();

	// Connect button handler
	document.getElementById('connectBtn')?.addEventListener('click', () => {
		const urlInput = document.getElementById('serverUrl') as HTMLInputElement;
		const namespaceInput = document.getElementById('namespace') as HTMLInputElement;

		const url = urlInput?.value.trim();
		const namespace = namespaceInput?.value.trim() || '/';

		if (!url) {
			alert('Please enter a URL');
			return;
		}

		const id = manager.createConnection(url, namespace);
		manager.connect(id);
	});

	// Allow Enter key to connect
	document.getElementById('serverUrl')?.addEventListener('keypress', (e) => {
		if (e.key === 'Enter') {
			document.getElementById('connectBtn')?.click();
		}
	});
	document.getElementById('namespace')?.addEventListener('keypress', (e) => {
		if (e.key === 'Enter') {
			document.getElementById('connectBtn')?.click();
		}
	});

	// Listen for theme changes and update editors
	const themeObserver = new MutationObserver(() => {
		// Access connections through a public method
		(manager as any).connections.forEach((state: ConnectionState) => {
			manager.updateEditorTheme(state);
		});
	});
	themeObserver.observe(document.documentElement, {
		attributes: true,
		attributeFilter: ['class'],
	});
</script>
